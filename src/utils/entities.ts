import { PatchEntity } from '../patches/entity/_index.js'
import { Entity } from '../entities/entity/_index.js'
import { QNPatch, QNSaveOptions } from '../patches/QNPatch.js'
import { ICreateChildEntity, ICreateEntity, IEventTriggers, IFullRef, IRefWithConstantValue, TRef } from '../types.js'
import { QNEntity } from '../lib.js'

export const ENTITY_ID_PREFIX = 'faad'

if(ENTITY_ID_PREFIX.length > 6) throw new Error('ERR: the entity id prefix should be less than 7 characters to allow for more ids')

export const generateRandomHex = (size: number) => [...Array(size)].map(() => Math.floor(Math.random() * 16).toString(16)).join('')
export const generateRandomEntityID = () => ENTITY_ID_PREFIX + generateRandomHex(16 - ENTITY_ID_PREFIX.length)
export const generateRandomEntityName = () => "Generated by QNS_" + generateRandomHex(16)

export function ensureID(entity: TRef | IRefWithConstantValue): TRef | IRefWithConstantValue {
  if(entity === null) return null
  if(entity instanceof PatchEntity) return entity.id
  if(entity instanceof Entity) return entity.id
  if(entity.hasOwnProperty('value')) {
    entity = entity as IRefWithConstantValue
    return {
      ...entity,
      ref: entity.ref instanceof PatchEntity || entity.ref instanceof Entity ? entity.ref.id : entity.ref,
      value: {
        ...entity.value,
        value: entity.value.value instanceof PatchEntity || entity.ref instanceof Entity ? entity.value.value.id : entity.value.value
      }
    }
  }
  if(entity.hasOwnProperty('ref') && ((entity as IFullRef).ref instanceof PatchEntity) || (entity as IFullRef).ref instanceof Entity) {
    return {
      ...(entity as IFullRef),
      ref: ((entity as IFullRef).ref as PatchEntity).id,
    } satisfies IFullRef
  }
  return entity
}

export function deepEnsureID<T extends { id: any }>(obj: T): T {
  if(obj === null) return null
  const result: { [key: string]: any } = {}
  if(obj instanceof String) return obj
  if(obj instanceof PatchEntity) return obj.id as T
  if(obj instanceof Entity) return obj.id as T
  for(const key of Object.keys(obj ?? {})) {
    if(obj.hasOwnProperty(key)) {
      const value = obj[key]
      if(value instanceof PatchEntity || value instanceof Entity || typeof value !== 'object') {
        result[key] = ensureID(value)
        continue
      }
      if(value?.[Symbol.iterator]) {
        result[key] = [...value].map(x => deepEnsureID(x))
        continue
      }
      result[key] = deepEnsureID(value)
    }
  }
  return result as T
}

export function ensurePatchEntity(patch: QNPatch, ref: TRef) {
  if(ref instanceof PatchEntity) return ref
  if(ref instanceof Entity) return new PatchEntity(patch, ref.id)
  if(typeof ref === 'string') return new PatchEntity(patch, ref)

  throw new Error(`the option to use full refs here hasn't been added yet (at ${ref})!`)
}

export function ensureEntity(entity: QNEntity, ref: TRef) {
  if(ref instanceof PatchEntity) return new Entity(entity, ref.id)
  if(ref instanceof Entity) return ref
  if(typeof ref === 'string') return new Entity(entity, ref)

  throw new Error(`the option to use full refs here hasn't been added yet (at ${ref})!`)
}

export const outputsToEvent = (outputs: IEventTriggers) => Object.fromEntries(Object.entries(outputs).map(([key, value]) => [key, value instanceof Array ? value.map(x => ensureID(x)) : ensureID(value)]))

export function ensureEventIDs<T extends ICreateEntity | ICreateChildEntity>(entityConfig: T): T {
  entityConfig.events = Object.fromEntries(
    Object.entries(entityConfig.events ?? {})
      .map(inpin => [inpin[0], Object.fromEntries(Object.entries(inpin[1] ?? {})
        .map(outpin => [outpin[0], outpin[1] instanceof Array ? outpin[1].map(out => ensureID(out)) : [ensureID(outpin[1])]])
      )])
  ) as any
  entityConfig.outputCopying = Object.fromEntries(
    Object.entries(entityConfig.outputCopying ?? {})
      .map(inpin => [inpin[0], Object.fromEntries(Object.entries(inpin[1] ?? {})
        .map(outpin => [outpin[0], outpin[1] instanceof Array ? outpin[1].map(out => ensureID(out)) : [ensureID(outpin[1])]])
      )])
  ) as any
  entityConfig.inputCopying = Object.fromEntries(
    Object.entries(entityConfig.inputCopying ?? {})
      .map(inpin => [inpin[0], Object.fromEntries(Object.entries(inpin[1] ?? {})
        .map(outpin => [outpin[0], outpin[1] instanceof Array ? outpin[1].map(out => ensureID(out)) : [ensureID(outpin[1])]])
      )])
  ) as any

  return entityConfig
}

export function ensurePropertyIDs<T extends ICreateChildEntity | ICreateEntity>(entityConfig: T): T {
  entityConfig.properties = Object.fromEntries(
    Object.entries(entityConfig.properties ?? {})
      .map(([propName, propValue]) => [
        propName,
        {
          ...propValue,
          value: propValue.value instanceof Array ? propValue.value.map(x => ensureID(x)) : ensureID(propValue.value)
        }
      ])
  )

  return entityConfig
}

export function ensureExposedIDs<T extends ICreateChildEntity | ICreateEntity>(entityConfig: T): T {
  entityConfig.exposedEntities = Object.fromEntries(
    Object.entries(entityConfig.exposedEntities ?? {})
    .map(([name, val]) => [
      name,
      {
        ...val,
        refersTo: val.isArray ? val.refersTo.map(x => ensureID(x)) : ensureID(val.refersTo as TRef)
      }
    ]) as any
  )
  return entityConfig
}

export function ensureEntityIDs<T extends ICreateChildEntity | ICreateEntity>(entityConfig: T): T {
  entityConfig = ensureEventIDs(entityConfig)
  entityConfig = ensurePropertyIDs(entityConfig)
  entityConfig = ensureExposedIDs(entityConfig)

  if(entityConfig.parent) entityConfig.parent = ensureID(entityConfig.parent) as TRef

  return entityConfig
}
